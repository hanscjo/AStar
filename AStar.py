
class Node():

    def __init__(self, parent = None, position = None):
        self.parent = parent;
        self.position = position;
        self.costLocal = 0;      #g(s)
        self.costGoal = 0;       #h(s)
        self.costSolution = 0;   #f(s)

    def __eq__(self,other):
        return self.position == other.position;

def mapSolver(map, start, goal):
    tileCost = {" . ": 1, " , ": 2, " : ": 3, " ; ": 4, " S ": 0, " G ": 0};  # Solution to find cost of traversing to a node, given by their string coding
    open_list = [];    #After attempting to run the program, I realised that I should have used proper queue implementations. Oh well.
    closed_list = [];

    #Initialize the start- and goal-nodes
    start_node = Node(None, start);
    start_node.costLocal = 0; start_node.costGoal = 0; start_node.costSolution = 0;
    goal_node = Node(None, goal);
    goal_node.costLocal = 0; goal_node.costGoal = 0; goal_node.costSolution = 0;

    open_list.append(start_node);  #We begin by appending the starting node

    while len(open_list) > 0:  #The agenda - we loop until we either find a path or have visited every node without success
        top_node = open_list[0];  #Gets the top-most node. Through the comparisons below, the node will always have the lowest f(s)-value
        top_index = 0;
        for index, node in enumerate(open_list):
            if node.costSolution < top_node.costSolution: #Did we find a better node?
                top_node = node;
                top_index = index;

        open_list.pop(top_index);  #We've covered our node, and we can leave it.
        closed_list.append(top_node);

        if top_node == goal_node:  #We found a solution!
            print("Fant en løsning!");
            solution = [];
            current_node = top_node;
            while current_node is not None:
                solution.append(current_node.position);
                current_node = current_node.parent;
            return solution[::-1];

        print(top_node.position)

        children = [];  #We start building the tree with children
        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0)]: #Iterate through the possible positions for potential neighbour-nodes

            node_position = (top_node.position[0] + new_position[0], top_node.position[1] + new_position[1]); #Definere position of a neighbouring node

            if map[node_position[0]][node_position[1]] == ' # ': #We make sure that we cannot traverse through walls, represented by the red tiles in the visualizations
                continue;

            if Node(top_node, node_position) in closed_list:  #If the node in question is already covered, we don't have to check it again
                continue;

            #If everything turns out alright, we can add the new child to our top_node
            new_child = Node(top_node, node_position);
            children.append(new_child);

        for child in children:  #Giving the children values
            for closed_child in closed_list: #Skip the child-node altogether if they already exist in the closed list. Avoids redundancy
                if child == closed_child:
                    continue;
            child.costLocal = top_node.costLocal + tileCost[map[child.position]];  #Make g(s) include the cost of traversing to the tile of the child
            child.costGoal = (abs(goal_node.position[0] - child.position[0]) + abs(goal_node.position[1] - child.position[1]));  #Calculates the 'Manhattan distance' towards the goal-node
            child.costSolution = child.costLocal + child.costGoal;  #f(s) = g(s) + h(s)

            for open_node in open_list: #If a child like this, who also has better g(s) values exists, we can skip appending this one
                if child == open_node and child.costLocal >= open_node.costLocal:
                    continue;

            open_list.append(child);


    #If we were to traverse every possible node without finding a solution
    return "Ingen løsning funnet!";

def runAStar(map):  #More or less a main-method. It's called by the individual "Task n" files. It obtains the solution path generated by the A*-algorithm, and uses it to update the map with the solution
    mapString = map.str_map;
    start = map.get_start_pos();
    goal = map.get_goal_pos();

    path = mapSolver(mapString, start, goal);
    print("finished")
    print(path)
    if (path != "Ingen løsning funnet!"):
        for i in path:
            if (mapString[i] != ' S ') and (mapString[i] != ' G '):
                mapString[i] = ' T '
    map.str_map = mapString;
